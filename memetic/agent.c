/**
 *	\file
 *	\brief Implements a local search technique to find a perturbation which
 *	modifies the chosen L-System to generate more difficult instances.
 *
 *	\author Farhan Ahammed (faha3615@mail.usyd.edu.au)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "../ls/ls.h"
#include "../util/upper_bound.h"
#include "../mt19937ar/t_mt19937ar.h"


mt_prng pert_rng;

char **names;
int names_size;



#define LINE_LENGTH   160    /* The maximum length of a line in an L-System file.            */
#define NUM_TSP_ITER   15    /* The number of times to run Concorde on an instance.          */
#define NUM_F_CHANGED   3    /* The number of 'F's to pertube at any one time.               */
#define NUM_RAND_INST  10    /* The number of random instances to generate (when pertubing). */


/**
 *	\brief Creates one TSPlib file generated by an L-System located in the
 *	specified file.
 *
 *	\param in_fname   The filename of the L-System file.
 *	\param lsname     The L-System in the file (in_fname) for which to generate
 *	                  the TSP instance.
 *	\param out_fname  The filename of the TSP file to be created.
 *	\param order      The order of the L-System to generate.
 */
void createTSPFile(char *in_fname, char *lsname, char *out_fname, int order)
{
	/* Compute the x-y coordinates of the instance represented by this L-System. */
	int numnodes = Lsystem(order, in_fname, lsname, "plots");
	printf("\nInstance Size: %d\n", numnodes);fflush(stdout);

	/* Now create a valid TSPlib file. */
	FILE *outfile_stream = fopen(out_fname, "w");

	/* Check that the file has sucessfully been opened */
	if (outfile_stream == NULL)
	{
		printf("ERROR: File '%s' could not be opened\n", out_fname);
		return;
	}

	/* Build the header file */
	fprintf(outfile_stream, "NAME: %s\n", lsname);
	fprintf(outfile_stream, "TYPE: TSP\n");
	fprintf(outfile_stream, "COMMENT: Created by Farhan Ahammed (farhan.ahammed@studentmail.newcastle.edu.au)\n");
	fprintf(outfile_stream, "DIMENSION: %d\n", numnodes);
	fprintf(outfile_stream, "EDGE_WEIGHT_TYPE: EUC_2D\n");
	fprintf(outfile_stream, "NODE_COORD_TYPE: TWOD_COORDS\n");
	fprintf(outfile_stream, "NODE_COORD_SECTION:\n");

	/* Add the coordinates of the points in this instance. */
	FILE *nodefile = fopen("plots", "r");
	char line[255];
	while(fgets(line, 255, nodefile) != NULL)
	{
		fprintf(outfile_stream, "%s", line);
	}
	remove("plots");
	fclose(nodefile);

	fprintf(outfile_stream, "EOF:\n");

	/* Close the file */
	int close_error_plot = fclose(outfile_stream);
	if (close_error_plot)
	{
		printf("ERROR: File '%s' could not be closed\n", out_fname);
	}
}


/**
 *	\brief Creates a random perturbation and stores it in the given ruleobj array.
 *
 *	Note: Only the unique characteristics of the perturbation are written to the
 *	array (i.e. the scale and angle). The other objects (e.g. 'G', 'F') must already
 *	be in the array.
 *
 *	\param p  The ruleobj array (<i>must be of length 8</i>) to store the
 *	          perturbation.
 */
void random_perturbation(ruleobj *p)
{
	int theta, phi;
	double a, e;

	a = genrand_real2(&pert_rng);
	theta = (int)(a*360);
	phi = 180 - theta;
	if (phi < 0) phi = 360 + phi;
	e = genrand_real3(&pert_rng);
	/* Make sure the epsilon doesn't get rounded down to 0.00 or up to 1.00 */
	if (e < 0.005) e = 0.01;
	if (e > 0.994) e = 0.99;

	sprintf(p[1].str, "@%0.2f",  e);
	sprintf(p[2].str, "\\%03d",  theta);
	sprintf(p[6].str, "\\%03d",  phi);
	sprintf(p[7].str, "@I%0.2f", e);
}


/**
 *	\brief A structure to store the location of an 'F'.
 */
typedef struct { int ruleNo, pos; } fpos_struct;


/**
 *	\brief Finds where each 'F' is located and returns an array of fpos_struct
 *	containing the location of each 'F'. You must <c>free()</c> the memory
 *	used by the array when done.
 *
 *	\param ls         The L-System.
 *	\param fposArray  An array of fpos_struct is created and returned in this
 *	                  parameter.
 *	\return The number of 'F's in the given L-System.
 */
int getListOfFs(lsystem *ls, fpos_struct **fposArray)
{
	fpos_struct *array;
	int i, j, k, n = 0;

	/* Keep a list of where all the 'F's are (ignoring the axiom). */
	for (i = 1; i < ls->numrules; i++)
		for (j = 0; j < ls->rulelength[i]; j++)
			if (ls->rule[i][j].type == F) n++;

	array = (fpos_struct *)malloc(sizeof(fpos_struct)*n);
	k = 0;
	for (i = 1; i < ls->numrules; i++)
	{
		for (j = 0; j < ls->rulelength[i]; j++)
		{
			if (ls->rule[i][j].type == F)
			{
				array[k].pos = j;
				array[k].ruleNo = i;
				k++;
			}
		}
	}
	*fposArray = array;
	return n;
}


/**
 *	\brief Changes the given int array to contain the next combination of numbers.
 *	No number is repeated more than once.
 *
 *	<b>Example.</b> Suppose we have the numbers {0,1,2,3,4} and want to choose three
 *	numbers each time. Then there are 10 combinations of 3 numbers and so this method
 *	will return:<br>
 *	0,1,2<br>
 *	0,1,3<br>
 *	0,1,4<br>
 *	0,2,3<br>
 *	0,2,4<br>
 *	0,3,4<br>
 *	1,2,3<br>
 *	1,2,4<br>
 *	1,3,4<br>
 *	2,3,4<br>
 *
<pre>
Some parts of this algorithm was obtained from:
    Kenneth H. Rosen, "Discrete Mathematics and Its Applications", 2nd edition,
    McGraw-Hill, 1991, pp. 284-286.
</pre>
 *
 *	\param positions  The array to contain the combinations of numbers.
 *	\param size       The size of the positions array.
 *	\param numFs      The number of 'F's in the L-System (and hence the largest
 *	                  number to be written in the positions array).
 *	\param reset      Set this parameter to true (1) to reset the combination to (0,0,...,0).
 *	\return True (1) if another combination was returned.
 */
int nextCombination(int *positions, int size, int numFs, int reset)
{
	int i, j;

	if (reset)
	{
		for (i = 0; i < size; i++)
			positions[i] = i;
		return 1;
	}

	/* Check if there are anymore combinations left. */
	if (positions[0] == numFs - size)
		return 0;

	i = size - 1;
	while (positions[i] == numFs - size + i)
	{
		i--;
	}
	positions[i]++;
	for (j = i + 1; j < size; j++)
	{
		positions[j] = positions[i] + j - i;
	}

	return 1;
}


/**
 *	\brief Returns the number of 'F's that will be replaced in the specified rule.
 *
 *	\param positions  The combination 'F's to replace.
 *	\param size       The size of the positions array.
 *	\param fposArray  The fpos_struct array containing the locations of all 'F' in
 *	                  the L-System.
 *	\param ruleNum    The rule for which you want to know how many 'F' in it will
 *	                  be replaced.
 *	\return ruleNum  The number of 'F's that will be replaced in the specified rule.
 */
int numInsertions(int *positions, int size, fpos_struct *fposArray, int ruleNum)
{
	int i, count = 0;
	for (i = 0; i < size; i++)
	{
		if (fposArray[positions[i]].ruleNo == ruleNum)
			count++;
	}
	return count;
}


/**
 *	\brief Creates different perturbations of an L-System in the given lsystem array.
 *	and tries to find the most fit/difficult perturbed L-System.
 *
 *	\param pop   An array of L-Systems (of which only one is used by this agent).
 *	\param size  The size of the pop array.
 */
void run(lsystem **pop, int size)
{
	int *instancesize, index = 0, i, j;
	char text[4];
	char *fname, lsname[50], *cmd;
	double temp_fit1, temp_fit2, origlowbound[NUM_ORDER_TEST];
	double rt, bb;
	FILE *fp;
	lsystem *ls;
	ruleobj pertarray[] =
	{
		{"G",     1, G},    {"@0.00", 5, SCALE}, {"\\000", 4, INCX}, {"F",      1, F},
		{"\\180", 4, INCX}, {"G",     1, G},     {"\\000", 4, INCX}, {"@I0.00", 6, SCALE}
	};

	/* The number of 'F's we'll modify at a time. */
	int numFs;
	fpos_struct *fposArray;

	if (names_size == 0)
	{
		printf("\nThere are no L-Systems (in the specified file) to analyse!");
		return;
	}
	else if (names_size > 1)
	{
		printf("There are more than one L-System in the file.\n");
		printf("Which one do you want to analyse?\n");
		for (i = 0; i < names_size; i++)
			printf("%d. %s\n", i+1, names[i]);
		fflush(stdout);

		if (fgets(text, 4, stdin) != NULL )
		{
			char *newline = strchr(text, '\n'); /* search for newline character */
			if (newline != NULL)
			{
				*newline = '\0'; /* overwrite trailing newline */
			}
			index = (int)strtol(text, NULL, 10) - 1;
		}
	}

	if (index >= names_size) index = 0;
	ls = pop[index];

	/* Create a list of where all the 'F's are located so that we can generate
	   every possible combination (nCr) of 'F'. */
	numFs = getListOfFs(ls, &fposArray);
	int combArray[NUM_F_CHANGED];

	fp = fopen("results.dat", "w");
	if (!fp)
	{
		printf("ERROR: Couldn't open file 'results.dat'\n");
		return;
	}

	fprintf(fp, "L-System: %s\n=======================================\n\n", names[index]);

	/* Run the base case (no pertubation). */
	temp_fit1 = fitness(ls);
	fprintf(fp, "Orig\t\t\t");
	for (i = 0; i < NUM_ORDER_TEST; i++)
	{
		fprintf(fp, "[(%9.4f)(%9.4f)(%9.4f)]   ", ls->runningtimes[i], ls->sd[i], ls->avgbbnodes[i]);
		/* Remember the original running times because we want an L-System that can do better than them. */
		origlowbound[i] = ls->runningtimes[i] - 2*ls->sd[i];
	}
	fprintf(fp, "%9.4f\n\n", temp_fit1);
	fflush(fp);
	fflush(stdout);


	/* oldrule[] will store the old rules so that they can be reset after
	   we finish using the modified versions. */
	ruleobj *oldrule[ls->numrules];
	int oldrulelen[ls->numrules];
	for (i = 0; i < ls->numrules; i++)
	{
		oldrule[i] = NULL;
		oldrulelen[i] = 0;
	}


	int rulepos = 1, numIns, count, curr_size, curr_len;
	nextCombination(combArray, NUM_F_CHANGED, numFs, 1);
	do
	{
		temp_fit2 = 0.0;
		count = 0;
		for (i = 1; i <= NUM_RAND_INST; i++)
		{
			print_ls(ls);
			/* Go through each of the chosen 'F's */
			j = 0;
			while (j < NUM_F_CHANGED)
			{
				rulepos = fposArray[combArray[j]].ruleNo;

				/* Count the number of 'F's in the current rule that will be replaced. */
				numIns = numInsertions(combArray, NUM_F_CHANGED, fposArray, rulepos);
				if (numIns > 0)
				{
					/* Keep a reference to the old rule so that we can reset the rule later on. */
					if (oldrule[rulepos] == NULL)
					{
						oldrule[rulepos] = ls->rule[rulepos];
						oldrulelen[rulepos] = ls->rulelength[rulepos];
						ls->rule[rulepos] = (ruleobj *)malloc((ls->rulelength[rulepos] + 7*numIns)*sizeof(ruleobj));
						ls->rulelength[rulepos] += 7*numIns;
					}


					/* Replace each 'F' in the current rule. Starting with the first. */
					/* Copy the grammar before the 'F'. */
					curr_len = fposArray[combArray[j]].pos*sizeof(ruleobj);
					memcpy(ls->rule[rulepos], oldrule[rulepos], curr_len);
					curr_size = curr_len/sizeof(ruleobj);

					/* Insert the perturbation. */
					random_perturbation(pertarray);
					curr_len = 8*sizeof(ruleobj);
					memcpy(ls->rule[rulepos] + curr_size, pertarray, curr_len);
					curr_size += curr_len/sizeof(ruleobj);

					j++;
					while ((j < NUM_F_CHANGED) && (fposArray[combArray[j]].ruleNo == rulepos))
					{
						/* Copy the grammer before the 'F'. */
						curr_len = (fposArray[combArray[j]].pos - fposArray[combArray[j-1]].pos - 1)*sizeof(ruleobj);
						memcpy(ls->rule[rulepos] + curr_size, oldrule[rulepos] + fposArray[combArray[j-1]].pos + 1, curr_len);
						curr_size += curr_len/sizeof(ruleobj);

						/* Insert the pertubation. */
						random_perturbation(pertarray);
						curr_len = 8*sizeof(ruleobj);
						memcpy(ls->rule[rulepos] + curr_size, pertarray, curr_len);
						curr_size += curr_len/sizeof(ruleobj);

						j++;
					}

					/* Concatenate the rest of the rule. */
					curr_len = (oldrulelen[rulepos] - fposArray[combArray[j-1]].pos - 1)*sizeof(ruleobj);
					memcpy(ls->rule[rulepos] + curr_size, oldrule[rulepos] + fposArray[combArray[j-1]].pos + 1, curr_len);
				}
			}

			/* Create the L-System file. */
			asprintf(&fname,  "pert_%d", combArray[0]);

			strcpy(lsname, "pert");
			char *tempstr;
			for (j = 0; j < NUM_F_CHANGED; j++)
			{
				asprintf(&tempstr, "_%d", combArray[j]);
				strcat(lsname, tempstr);
			}
			asprintf(&tempstr, "_%d", i);
			strcat(lsname, tempstr);
			savetofile(ls, fname, lsname, NULL);

			/* Find the fitness of the file. */
			ls->computed_f = 0;
			printf("Computing fitness of L-System: %s\n", lsname); fflush(stdout);
			/* Find the average and standard deviations of the running times and number of bb nodes. */
			fitness(ls);

			/* 'Fitness' has a differnt meaning now, because we now have a base case
			   to compare to (i.e. the original fractal). */
			temp_fit1 = 0;
			for (j = 0; j < NUM_ORDER_TEST; j++)
			{
				if (ls->instancesize[j] > 100)
					temp_fit1 += j*((ls->runningtimes[j] - 2*ls->sd[j]) - origlowbound[j]);
			}

			fprintf(fp, "%s\t\t\t", lsname);
			for (j = 0; j < NUM_ORDER_TEST; j++)
			{
				fprintf(fp, "[(%9.4f)(%9.4f)(%9.4f)]   ", ls->runningtimes[j], ls->sd[j], ls->avgbbnodes[j]);
			}
			fprintf(fp, "%9.4f\n", temp_fit1);
			printf("%s fitness: %0.4f\n", lsname, temp_fit1);
			fflush(fp);
			fflush(stdout);
			temp_fit2 += temp_fit1;

			/* Clean up and reset the rules. */
			for (j = 0; j < ls->numrules; j++)
			{
				if (oldrule[j] != NULL)
				{
					free(ls->rule[j]);
					ls->rule[j] = oldrule[j];
					ls->rulelength[j] = oldrulelen[j];
					oldrule[j] = NULL;
				}
			}

			/* Make an indication as to how many 'very fit' L-Systems there are.
			   The larger the fitness, the larger the count. If the count is large enough,
			   we will assume there is a chance of finding more difficult/fit L-Systems
			   and continue to sample random pertubations. */
			if (temp_fit1 >  50) count++;
			if (temp_fit1 > 100) count++;
			if (temp_fit1 > 200) count++;

			/* If after 20 samples, we don't have enough good instances, then it's
			   time to move on to the next combination. */
			if ((i == 20) && (count < 5))
			{
				fprintf(fp, "*** not enough difficult instances ***\n");
				break;
			}
		}
		fprintf(fp, "-----------------------------\nAverage\t\t\t%0.4f\n\n\n", temp_fit2/NUM_RAND_INST);  fflush(fp);
	} while (nextCombination(combArray, NUM_F_CHANGED, numFs, 0));

	fclose(fp);
	free(fposArray);
}


/**
 *	\brief Starts the program.
 *
 *	One argument is expected. The program is run like this:
 *	\code
 *  <program name> <ifs file>
 *	\endcode
 */
int main(int argc, char** argv)
{

	char *filename;
	if (argc != 2)
	{
		printf("Usage: %s <filename>\n", argv[0]);
	}
	else
		filename = argv[1];

	FILE *fp = fopen(filename,"r");
	if(fp)
	{
		fclose(fp);
		/* Create/Empty the file because ls.c only appends to the file. */
		fp = fopen("temp.l", "w");
		fclose(fp);
		/* Load any L-Systems the user specified. */
		int i, n;
		lsystem **temp;
		fp = fopen(filename, "r");
		n = readfile(fp, &temp, &names);
		if (fclose(fp)) printf("ERROR: File '%s' could not be closed\n", filename);
		names_size = n;

		init_genrand(&pert_rng, time(NULL));


		/**
		int numnodes;
		printf("\n");
		for (i = 0; i < names_size; i++)
		{
			numnodes = Lsystem(14, filename, names[i], "plots");
			printf("%s: %d\n", names[i], numnodes);
		}
		/**/


		run(temp, n);/**/
		printf("\n");
		printf("deleting L-Systems ... Program completed successfully\n");
		for (i = 0; i < n; i++)
		{
			delete_ls(temp[i]);
			free(names[i]);
		}
		free(names);
		free(temp);
	}
}
