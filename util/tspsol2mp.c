/**
 *	\file
 *	\brief Given a TSPlib file and a corresponding solution file, this program
 *	will compute the total cost of the tour and if requested, create a PostScript
 *	file (generated by METAPOST) containing the graphical representation of the tour.
 *
 *	\author Farhan Ahammed (faha3615@mail.usyd.edu.au)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define LINE_LENGTH 255

typedef struct
{
	int id, x, y;
} tsp_2d_node;

int numnodes, *sol, max;
int adj_list, disp_cities, disp_edges, disp_labels, create_eps;
tsp_2d_node *node;
char *delims = " :\t\n";


/**
 *	\brief Sets the dimension (allocates the required amount of memory for the
 *	arrays) if the given line is the string "DIMENSION: XXX" where XXX is the
 *	number of cities in the TSP file.
 *
 *	\param line  A line from a TSPlib file.
 */
int setDimension(char *line)
{
	char *temp = strtok(line, delims);
	if (!strcmp(temp, "DIMENSION"))
	{
		temp = strtok(NULL, delims);
		numnodes = (int)strtol(temp, NULL, 10);
		node = (tsp_2d_node *)malloc(sizeof(tsp_2d_node)*numnodes);
		if (node == NULL)
		{
			printf("ERROR: Couldn't allocate memory for node array\n");
			exit(EXIT_FAILURE);
		}

		sol = (int *)malloc(sizeof(int)*numnodes);
		if (sol == NULL)
		{
			printf("ERROR: Couldn't allocate memory for sol array\n");
			free(node);
			exit(EXIT_FAILURE);
		}

		return 1;
	}
	return 0;
}


/**
 *	\brief Returns true if the given line is "NODE_COORD_SECTION". That is,
 *	the city coordinates begins from the next line in the TSPlib file.
 *
 *	\param line  A line from a TSPlib file.
 */
int isNodeCoordHeader(char *line)
{
	char *temp = strtok(line, delims);
	if (!strcmp(temp, "NODE_COORD_SECTION"))
		return 1;
	else
		return 0;
}


/**
 *	\brief Extracts the node/city's coordinates from the given string and places
 *	them in the variables pointed to by the given pointers.
 *
 *	The string must be formatted like so: "<i>ID x-coord y-coord</i>"
 *
 *	\param line    A line from a TSPlib file containing a city's ID and position.
 *	\param id      The city's id is returned in this parameter.
 *	\param xcoord  The city's x-coordinate is returned in this parameter.
 *	\param ycoord  The city's y-coordinate is returned in this parameter.
 *	\return  True (1) if the string contains "EOF". That is, there are no more
 *	         cities left in the TSPlib file.
 */
int extractNodeData(char *line, int *id, int *xcoord, int *ycoord)
{
	char *temp = strtok(line, delims);
	if (!strcmp(temp, "EOF"))
		return 1;
	else
	{
		*id = (int)strtol(temp, NULL, 10);

		temp = strtok(NULL, delims);
		*xcoord = (int)strtol(temp, NULL, 10);

		temp = strtok(NULL, delims);
		*ycoord = (int)strtol(temp, NULL, 10);

		if (*xcoord > max) max = *xcoord;
		if (*ycoord > max) max = *ycoord;
	}
	return 0;
}


/**
 *	\brief Reads the given TSPlib file and stores the information about all the
 *	cities in the node array (and the numnodes variable).
 *
 *	\param tspfilename  The file name of the TSPlib file.
 */
void read_tsp_file(char *tspfilename)
{
	char line[LINE_LENGTH], *temp;
	int finished = 0, got_dimension = 0, reading_node_data = 0, i;
	FILE *tspfp;

	tspfp = fopen(tspfilename, "r");
	if (tspfp == NULL)
	{
		printf("ERROR: Couldn't open TSP file '%s'\n", tspfilename);
		exit(EXIT_FAILURE);
	}

	while (!finished)
	{
		if (fgets(line, LINE_LENGTH, tspfp) != NULL)
		{
			char *newline = strchr(line, '\n'); /* search for newline character */
			if (newline != NULL)
			{
				*newline = '\0'; /* overwrite trailing newline */
			}

			strupr(line);
			if (!got_dimension)
				got_dimension = setDimension(line);
			else if (!reading_node_data)
			{
				if (isNodeCoordHeader(line))
				{
					reading_node_data = 1;
					i = 0;
				}
			}
			else
			{
				finished = extractNodeData(line, &(node[i].id), &(node[i].x), &(node[i].y));
				i++;
			}
		}
		else
			finished = 1;
	}
	fclose(tspfp);
}


/**
 *	\brief Reads the given TSP solution file and stores the tour/solution in the
 *	sol array.
 *
 *	\param solfilename  The file name of the TSP solution file.
 */
void read_sol_file(char *solfilename)
{
	FILE *solfp;
	int finished = 0, i = 0;
	char line[LINE_LENGTH], *temp;

	solfp = fopen(solfilename, "r");
	if (solfp == NULL)
	{
		printf("ERROR: Couldn't open TSP solution file '%s'\n", solfilename);
		exit(EXIT_FAILURE);
	}

	/* The first line contains only one number --- the dimension. We already have this
	   information and so we don't need it. */
	if (fgets(line, LINE_LENGTH, solfp) == NULL)
		finished = 1;

	while (!finished)
	{
		if (fgets(line, LINE_LENGTH, solfp) != NULL)
		{
			char *newline = strchr(line, '\n'); /* search for newline character */
			if (newline != NULL)
			{
				*newline = '\0'; /* overwrite trailing newline */
			}

			temp = strtok(line, delims);

			if (adj_list)
			{
				sol[i] = (int)strtol(temp, NULL, 10);
				i++;
			}
			else
			{
				while (temp != NULL)
				{
					sol[i] = (int)strtol(temp, NULL, 10);
					i++;
					temp = strtok(NULL, delims);
				}
			}
		}
		else
			finished = 1;
	}
	fclose(solfp);
}


/**
 *	\brief Creates a METAPOST file and uses the external \c mpost program to create
 *	a PostScript file containing a graphical representation of the solution.
 *
 *	\param solfilename  The file name of the TSP solution file. This name is used
 *	                    to define the file name of the METAPOST file that will be
 *	                    created.
 */
void create_mp_file(char *solfilename)
{
	char *str;
	FILE *mpfp;
	int i, j;

	if (create_eps)
	{
		str = (char *)malloc(strlen(solfilename) + 4);
		sprintf(str, "%s.mp", solfilename);
		mpfp = fopen(str, "w");
		if (mpfp == NULL)
		{
			printf("ERROR: Couldn't create MetaPost file '%s'\n", str);
			exit(EXIT_FAILURE);
		}

		/* Let's begin. */
		fprintf(mpfp, "beginfig(1);\n\nu = 1cm;\n\n");

		/*********************************************************************************
		 *  NOTE: The nodes (in the .mp file) are labelled 0..n because the labels       *
		 *        obtained from the TSP file are not used by Concorde. For some reason,  *
		 *        the Concorde program does not use the actual node labels when creating *
		 *        the solution file. So if the first city is given the label 1 (in the   *
		 *        TSP file) then it is referred to as city 0 in the solution file.       *
		 *                                                                               *
		 *        If this ever changes, some of the 'i's in the fprintf statements must  *
		 *        be replaced with node[i].id.                                           *
		 *********************************************************************************/

		if (disp_labels)
			fprintf(mpfp, "drawoptions(withcolor .8white);\n");

		/* Plot the nodes/cities. MetaPost doesn't like numbers larger than 4096, so
		   we will make sure that the size of the drawing is at most 20cm x 20cm. */
		if (disp_cities)
		{
			fprintf(mpfp, "\n");
			fprintf(mpfp, "pickup pencircle scaled 3pt;\n");
			for (i = 0; i < numnodes; i++)
			{
				fprintf(mpfp, "drawdot (%.4f*u, %.4f*u);\n", 20.0*node[i].x/max, 20.0*node[i].y/max);
			}
			fprintf(mpfp, "\n");
		}
	}


	/* Compute the cost and/or draw the solution path. */
	if (disp_edges)
		fprintf(mpfp, "pickup pencircle scaled 1pt;\n");
	double cost = 0.0;
	i = 0;
	while (i < numnodes)
	{
		if (i < numnodes)
		{
			if (disp_edges)
				fprintf(mpfp, "draw (%.4f*u, %.4f*u)", 20.0*node[sol[i]].x/max, 20.0*node[sol[i]].y/max);
			i++;
		}
		for (j = 0; j < 5 && i < numnodes; j++)
		{
			if (disp_edges)
				fprintf(mpfp, "--(%.4f*u, %.4f*u)", 20.0*node[sol[i]].x/max, 20.0*node[sol[i]].y/max);
			cost += sqrt((node[sol[i]].x - node[sol[i-1]].x)*(node[sol[i]].x - node[sol[i-1]].x) + (node[sol[i]].y - node[sol[i-1]].y)*(node[sol[i]].y - node[sol[i-1]].y));
			i++;
		}
		if (disp_edges)
			fprintf(mpfp, ";\n");

		/* We need to plot the last city plotted (in the for loop) again to ensure that
		   there is a cycle. */
		if (i < numnodes) i--;
	}
	/* Finish the cycle. */
	if (disp_edges)
		fprintf(mpfp, "draw (%.4f*u, %.4f*u)--(%.4f*u, %.4f*u);\n", 20.0*node[sol[numnodes-1]].x/max, 20.0*node[sol[numnodes-1]].y/max, 20.0*node[sol[0]].x/max, 20.0*node[sol[0]].y/max);
	cost += sqrt((node[sol[numnodes-1]].x - node[sol[0]].x)*(node[sol[numnodes-1]].x - node[sol[0]].x) + (node[sol[numnodes-1]].y - node[sol[0]].y)*(node[sol[numnodes-1]].y - node[sol[0]].y));


	/* Label each node/city. */
	if (disp_labels)
	{
		fprintf(mpfp, "\n");
		fprintf(mpfp, "drawoptions(withcolor black);\n");
		fprintf(mpfp, "\n");
		fprintf(mpfp, "defaultscale := 0.2;\n");
		for (i = 0; i < numnodes; i++)
		{
			fprintf(mpfp, "label.bot(\"%d\", (%.4f*u, %.4f*u));\n", sol[i], 20.0*node[sol[i]].x/max, 20.0*node[sol[i]].y/max);
		}
		fprintf(mpfp, "\n");
	}


	printf("\nCost: %.4f\n\n", cost);

	if (create_eps)
	{
		/* We're done. */
		fprintf(mpfp, "endfig;\n\n");
		fprintf(mpfp, "%% Cost: %.4f\n", cost);
		fclose(mpfp);

		char *command;
		asprintf(&command, "mpost %s", str);
		system(command);
		free(str);
	}
}


/**
 *	\brief Displays the given message on screen and obtains the user's input.
 *
 *	\param message     The message to display on screen.
 *	\param input       The string to store the user's input.
 *	\param input_size  The size of the string input.
 */
void input_str(char *message, char *input, int input_size)
{
	fputs(message, stdout);
	fflush(stdout);
	if (fgets(input, input_size, stdin) != NULL)
	{
		char *newline = strchr(input, '\n'); /* search for newline character */
		if (newline != NULL)
		{
			*newline = '\0'; /* overwrite trailing newline */
		}
	}
}


/**
 *	\brief Displays the program's help (i.e. how to invoke the program and what
 *	options are available) on the screen.
 *
 *	\param prog  The name of this program.
 */
void display_help(char *prog)
{
	printf("Usage: %s [-OPTION(S)] <TSPlib file> <Solution file>\n", prog);
	printf("\n");
	printf("  -a  Tells the program the TSP solution is represented as an adjacency/edge list.\n");
	printf("      Otherwise, it is assumed the solution is represented as a sequence of nodes.\n");
	printf("  -c  Displays the cities.\n");
	printf("  -e  Displays the edges.\n");
	printf("  -l  Displays the labels.\n");
	printf("  -h  Displays this help and exits.\n");
	printf("\n");
	printf("If you choose not to display anything, then no METAPOST and PostScript files will\n");
	printf("be created. Only the cost of the tour is displayed.\n");
}


int main(int argc, char **argv)
{
	char *t, *s;

	adj_list = 0;
	disp_cities = 0;
	disp_edges = 0;
	disp_labels = 0;
	create_eps = 0;

	/* Check if the user gave any of the option arguments. */
	int c;
	while ((c = getopt (argc, argv, ":acelh")) != -1)
	{
		switch (c)
		{
			case 'a':
				adj_list = 1;
				break;
			case 'c':
				disp_cities = 1;
				break;
			case 'e':
				disp_edges = 1;
				break;
			case 'l':
				disp_labels = 1;
				break;
			case 'h':
				display_help(argv[0]);
				return 1;
			case '?':
				fprintf(stderr, "Ignoring unrecognized option: -%c\n", optopt);
		}
	}
	create_eps = (disp_cities || disp_edges || disp_labels);

	/* Get the tsp and solution file names. */
	if ((argc - optind) < 2)
	{
		display_help(argv[0]);
		return 1;
	}
	else
	{
		t = argv[optind];
		s = argv[optind+1];
	}

	node = NULL;
	sol  = NULL;
	max = 0;

	read_tsp_file(t);
	read_sol_file(s);
	if (numnodes == 0)
		printf("There are no nodes/cities in the tsp file.\n");
	else
		create_mp_file(s);

	if (node != NULL) free(node);
	if (sol  != NULL) free(sol);

	return EXIT_SUCCESS;
}
